{"name":"Set","qualifiedName":"dart:core.Set","comment":"<p>A collection of objects in which each object can occur only once.</p>\n<p>That is, for each object of the element type, the object is either considered\nto be in the set, or to <em>not</em> be in the set.</p>\n<p>Set implementations may consider some elements indistinguishable. These\nelements are treated as being the same for any operation on the set.</p>\n<p>The default <a>dart:core.Set</a> implementation, <a>dart:collection.LinkedHashSet</a>, considers objects\nindistinguishable if they are equal with regard to\noperator <a>dart:core.Object.==</a>.</p>\n<p>Iterating over elements of a set may be either unordered\nor ordered in some way. Examples:</p><ul><li>\n<p>A <a>dart:collection.HashSet</a> is unordered, which means that its iteration order is\n  uspecified,</p></li><li><a>dart:collection.LinkedHashSet</a> iterates in the insertion order of its elements, and</li><li>a sorted set like <a>dart:collection.SplayTreeSet</a> iterates the elements in sorted order.</li></ul>\n<p>It is generally not allowed to modify the set (add or remove elements) while\nan operation on the set is being performed, for example during a call to\n<a>dart:core.IterableBase.forEach</a> or <a>dart:core.Set.containsAll</a>. Nor is it allowed to modify the set while\niterating either the set itself or any <a>dart:core.Iterable</a> that is backed by the set,\nsuch as the ones returned by methods like <a>dart:core.IterableBase.where</a> and <a>dart:core.IterableBase.map</a>.</p>","isAbstract":true,"superclass":"dart:core.IterableBase","implements":[],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"iterator":{"name":"iterator","qualifiedName":"dart:core.Set.iterator","comment":"<p>Provides an iterator that iterates over the elements of this set.</p>\n<p>The order of iteration is defined by the individual <code>Set</code> implementation,\nbut must be consistent between changes to the set.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.Iterator","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"dart:core.Set.Set-","comment":"<p>Creates an empty <a>dart:core.Set</a>.</p>\n<p>The created <a>dart:core.Set</a> is a plain <a>dart:collection.LinkedHashSet</a>.\nAs such, it considers elements that are equal (using <a>dart:core.Set.==</a>) to be\nindistinguishable, and requires them to have a compatible\n<a>dart:core.Set.hashCode</a> implementation.</p>\n<p>The set is equivalent to one created by <code>new LinkedHashSet&lt;E&gt;()</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"parameters":{},"annotations":[]},"from":{"name":"from","qualifiedName":"dart:core.Set.Set-from","comment":"<p>Creates a <a>dart:core.Set</a> that contains all <a>dart:core.Set.Set-from.elements</a>.</p>\n<p>All the <a>dart:core.Set.Set-from.elements</a> should be assignable to <a>dart:core.Set.E</a>.\nThe <code>elements</code> iterable itself can have any type,\nso this constructor can be used to down-cast a <code>Set</code>, for example as:</p>\n<pre><code>Set&lt;SuperType&gt; superSet = ...;\nSet&lt;SubType&gt; subSet =\n    new Set&lt;SubType&gt;.from(superSet.where((e) =&gt; e is SubType));\n</code></pre>\n<p>The created <a>dart:core.Set</a> is a <a>dart:collection.LinkedHashSet</a>. As such, it considers elements that\nare equal (using <a>dart:core.Set.==</a>) to be indistinguishable, and requires them to\nhave a compatible <a>dart:core.Set.hashCode</a> implementation.</p>\n<p>The set is equivalent to one created by\n<code>new LinkedHashSet&lt;E&gt;.from(elements)</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"parameters":{"elements":{"name":"elements","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"identity":{"name":"identity","qualifiedName":"dart:core.Set.Set-identity","comment":"<p>Creates an empty identity <a>dart:core.Set</a>.</p>\n<p>The created <a>dart:core.Set</a> is a <a>dart:collection.LinkedHashSet</a> that uses identity as equality\nrelation.</p>\n<p>The set is equivalent to one created by <code>new LinkedHashSet&lt;E&gt;.identity()</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"parameters":{},"annotations":[]}},"operators":{},"methods":{"add":{"name":"add","qualifiedName":"dart:core.Set.add","comment":"<p>Adds <a>dart:core.Set.add.value</a> into the set. Returns <code>true</code> if <a>dart:core.Set.add.value</a> was added to the set.</p>\n<p>If <a>dart:core.Set.add.value</a> already exists, the set is not changed and <code>false</code> is returned.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Set.E","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"addAll":{"name":"addAll","qualifiedName":"dart:core.Set.addAll","comment":"<p>Adds all <a>dart:core.Set.addAll.elements</a> to this Set.</p>\n<p>Equivalent to adding each element in <a>dart:core.Set.addAll.elements</a> using <a>dart:core.Set.add</a>,\nbut some collections may be able to optimize it.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"elements":{"name":"elements","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"clear":{"name":"clear","qualifiedName":"dart:core.Set.clear","comment":"<p>Removes all elements in the set.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"contains":{"name":"contains","qualifiedName":"dart:core.Set.contains","comment":"<p>Returns true if <a>dart:core.Set.contains.value</a> is in the set.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsAll":{"name":"containsAll","qualifiedName":"dart:core.Set.containsAll","comment":"<p>Returns whether this Set contains all the elements of <a>dart:core.Set.containsAll.other</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"difference":{"name":"difference","qualifiedName":"dart:core.Set.difference","comment":"<p>Returns a new set with the the elements of this that are not in <a>dart:core.Set.difference.other</a>.</p>\n<p>That is, the returned set contains all the elements of this <a>dart:core.Set</a> that\nare not elements of <a>dart:core.Set.difference.other</a> according to <code>other.contains</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"intersection":{"name":"intersection","qualifiedName":"dart:core.Set.intersection","comment":"<p>Returns a new set which is the intersection between this set and <a>dart:core.Set.intersection.other</a>.</p>\n<p>That is, the returned set contains all the elements of this <a>dart:core.Set</a> that\nare also elements of <a>dart:core.Set.intersection.other</a> according to <code>other.contains</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"lookup":{"name":"lookup","qualifiedName":"dart:core.Set.lookup","comment":"<p>If an object equal to <a>dart:core.Set.lookup.object</a> is in the set, return it.</p>\n<p>Checks if there is an object in the set that is equal to <a>dart:core.Set.lookup.object</a>.\nIf so, that object is returned, otherwise returns null.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.Set.E","inner":[]}],"parameters":{"object":{"name":"object","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"remove":{"name":"remove","qualifiedName":"dart:core.Set.remove","comment":"<p>Removes <a>dart:core.Set.remove.value</a> from the set. Returns true if <a>dart:core.Set.remove.value</a> was\nin the set. Returns false otherwise. The method has no effect\nif <a>dart:core.Set.remove.value</a> value was not in the set.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"removeAll":{"name":"removeAll","qualifiedName":"dart:core.Set.removeAll","comment":"<p>Removes each element of <a>dart:core.Set.removeAll.elements</a> from this set.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"elements":{"name":"elements","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"removeWhere":{"name":"removeWhere","qualifiedName":"dart:core.Set.removeWhere","comment":"<p>Removes all elements of this set that satisfy <a>dart:core.Set.removeWhere.test</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Set.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"retainAll":{"name":"retainAll","qualifiedName":"dart:core.Set.retainAll","comment":"<p>Removes all elements of this set that are not elements in <a>dart:core.Set.retainAll.elements</a>.</p>\n<p>Checks for each element of <a>dart:core.Set.retainAll.elements</a> whether there is an element in this\nset that is equal to it (according to <code>this.contains</code>), and if so, the\nequal element in this set is retained, and elements that are not equal\nto any element in <code>elements</code> are removed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"elements":{"name":"elements","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"retainWhere":{"name":"retainWhere","qualifiedName":"dart:core.Set.retainWhere","comment":"<p>Removes all elements of this set that fail to satisfy <a>dart:core.Set.retainWhere.test</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Set.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"toSet":{"name":"toSet","qualifiedName":"dart:core.Set.toSet","comment":"","commentFrom":"dart:core.IterableBase.toSet","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"parameters":{},"annotations":[]},"union":{"name":"union","qualifiedName":"dart:core.Set.union","comment":"<p>Returns a new set which contains all the elements of this set and <a>dart:core.Set.union.other</a>.</p>\n<p>That is, the returned set contains all the elements of this <a>dart:core.Set</a> and\nall the elements of <a>dart:core.Set.union.other</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.Set.E","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"first":{"name":"first","qualifiedName":"dart:core.Set.first","comment":"<p>Returns the first element.</p>\n<p>Throws a <a>dart:core.StateError</a> if <code>this</code> is empty.\nOtherwise returs the first element in the iteration order,\nequivalent to <code>(iterator..moveNext())..current</code>.</p>","commentFrom":"dart:core.Iterable.first","inheritedFrom":"dart:core.IterableBase.first","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"dart:core.Set.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart:core.Set.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{},"annotations":[]},"isEmpty":{"name":"isEmpty","qualifiedName":"dart:core.Set.isEmpty","comment":"<p>Returns <code>true</code> if there are no elements in this collection.</p>\n<p>May be computed by checking if <code>iterator.moveNext()</code> returns <code>false</code>.</p>","commentFrom":"dart:core.Iterable.isEmpty","inheritedFrom":"dart:core.IterableBase.isEmpty","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{},"annotations":[]},"isNotEmpty":{"name":"isNotEmpty","qualifiedName":"dart:core.Set.isNotEmpty","comment":"<p>Returns true if there is at least one element in this collection.</p>\n<p>May be computed by checking if <code>iterator.moveNext()</code> returns <code>true</code>.</p>","commentFrom":"dart:core.Iterable.isNotEmpty","inheritedFrom":"dart:core.IterableBase.isNotEmpty","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{},"annotations":[]},"iterator":{"name":"iterator","qualifiedName":"dart:core.Set.iterator","comment":"<p>Returns a new <code>Iterator</code> that allows iterating the elements of this\n<code>Iterable</code>.</p>\n<p>Iterable classes may specify the iteration order of their elements\n(for example <a>dart:core.List</a> always iterate in index order),\nor they may leave it unspecified (for example a hash-based <a>dart:core.Set</a>\nmay iterate in any order).</p>\n<p>Each time <code>iterator</code> is read, it returns a new iterator,\nwhich can be used to iterate through all the elements again.\nThe iterators of the same iterable can be stepped through independently,\nbut should return the same elements in the same order,\nas long as the underlying collection isn't changed.</p>\n<p>Modifying the collection may cause new iterators to produce\ndifferent elements, and may change the order of existing elements.\nA <a>dart:core.List</a> specifies its iteration order precisely,\nso modifying the list changes the iteration order predictably.\nA hash-based <a>dart:core.Set</a> may change its iteration order completely\nwhen adding a new element to the set.</p>\n<p>Modifying the underlying collection after creating the new iterator\nmay cause an error the next time <a>dart:core.Iterator.moveNext</a> is called\non that iterator.\nAny <em>modifiable</em> iterable class should specify which operations will\nbreak iteration.</p>","commentFrom":"","inheritedFrom":"dart:core.Iterable.iterator","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.Iterator","inner":[{"outer":"dart:core.Iterable.E","inner":[]}]}],"parameters":{},"annotations":[]},"last":{"name":"last","qualifiedName":"dart:core.Set.last","comment":"<p>Returns the last element.</p>\n<p>Throws a <a>dart:core.StateError</a> if <code>this</code> is empty.\nOtherwise may iterate through the elements and returns the last one\nseen.\nSome iterables may have more efficient ways to find the last element\n(for example a list can directly access the last element,\nwithout iterating through the previous ones).</p>","commentFrom":"dart:core.Iterable.last","inheritedFrom":"dart:core.IterableBase.last","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{},"annotations":[]},"length":{"name":"length","qualifiedName":"dart:core.Set.length","comment":"<p>Returns the number of elements in the iterable.</p>\n<p>This is an efficient operation that doesn't require iterating through\nthe elements.</p>","commentFrom":"","inheritedFrom":"dart:core.EfficientLength.length","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart:core.Set.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Type","inner":[]}],"parameters":{},"annotations":[]},"single":{"name":"single","qualifiedName":"dart:core.Set.single","comment":"<p>Checks that this iterable has only one element, and returns that element.</p>\n<p>Throws a <a>dart:core.StateError</a> if <code>this</code> is empty or has more than one element.</p>","commentFrom":"dart:core.Iterable.single","inheritedFrom":"dart:core.IterableBase.single","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart:core.Set.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart:core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart:core.Set.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart:core.Set.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"any":{"name":"any","qualifiedName":"dart:core.Set.any","comment":"<p>Checks whether any element of this iterable satisfies test.</p>\n<p>Checks every element in iteration order, and returns <code>true</code> if\nany of them make test return <code>true</code>, otherwise returns false.</p>","commentFrom":"dart:core.Iterable.any","inheritedFrom":"dart:core.IterableBase.any","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"contains":{"name":"contains","qualifiedName":"dart:core.Set.contains","comment":"<p>Returns true if the collection contains an element equal to <a>dart:core.Set.contains.element</a>.</p>\n<p>This operation will check each element in order for being equal to\n<a>dart:core.Set.contains.element</a>, unless it has a more efficient way to find an element\nequal to <a>dart:core.Set.contains.element</a>.</p>\n<p>The equality used to determine whether <a>dart:core.Set.contains.element</a> is equal to an element of\nthe iterable defaults to the Object.operator== of the element.</p>\n<p>Some types of iterable may have a different equality used for its elements.\nFor example, a <a>dart:core.Set</a> may have a custom equality\n(see Set.identical) that its <code>contains</code> uses.\nLikewise the <code>Iterable</code> returned by a <a>dart:core.Map.keys</a> call\nshould use the same equality that the <code>Map</code> uses for keys.</p>","commentFrom":"dart:core.Iterable.contains","inheritedFrom":"dart:core.IterableBase.contains","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"elementAt":{"name":"elementAt","qualifiedName":"dart:core.Set.elementAt","comment":"<p>Returns the <a>dart:core.Set.elementAt.index</a>th element.</p>\n<p>The <a>dart:core.Set.elementAt.index</a> must be non-negative and less than <a>dart:core.Set.length</a>.\nIndex zero represents the first element (so <code>iterable.elementAt(0)</code> is\nequivalent to <code>iterable.first</code>).</p>\n<p>May iterate through the elements in iteration order, skipping the\nfirst <code>index</code> elements and returning the next.\nSome iterable may have more efficient ways to find the element.</p>","commentFrom":"dart:core.Iterable.elementAt","inheritedFrom":"dart:core.IterableBase.elementAt","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{"index":{"name":"index","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"every":{"name":"every","qualifiedName":"dart:core.Set.every","comment":"<p>Checks whether every element of this iterable satisfies test.</p>\n<p>Checks every element in iteration order, and returns <code>false</code> if\nany of them make test return <code>false</code>, otherwise returns <code>true</code>.</p>","commentFrom":"dart:core.Iterable.every","inheritedFrom":"dart:core.IterableBase.every","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"expand":{"name":"expand","qualifiedName":"dart:core.Set.expand","comment":"<p>Expands each element of this <a>dart:core.Iterable</a>into zero or more elements.</p>\n<p>The resulting Iterable runs through the elements returned\nby <a>dart:core.Set.expand.f</a> for each element of this, in iteration order.</p>\n<p>The returned <a>dart:core.Iterable</a> is lazy, and calls <a>dart:core.Set.expand.f</a> for each element\nof this every time it's iterated.</p>","commentFrom":"dart:core.Iterable.expand","inheritedFrom":"dart:core.IterableBase.expand","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Iterable","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.Iterable","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"firstWhere":{"name":"firstWhere","qualifiedName":"dart:core.Set.firstWhere","comment":"<p>Returns the first element that satisfies the given predicate <a>dart:core.Set.firstWhere.test</a>.</p>\n<p>Iterates through elements and returns the first to satsify <a>dart:core.Set.firstWhere.test</a>.</p>\n<p>If no element satisfies <a>dart:core.Set.firstWhere.test</a>, the result of invoking the <a>dart:core.Set.firstWhere.orElse</a>\nfunction is returned.\nIf <a>dart:core.Set.firstWhere.orElse</a> is omitted, it defaults to throwing a <a>dart:core.StateError</a>.</p>","commentFrom":"dart:core.Iterable.firstWhere","inheritedFrom":"dart:core.IterableBase.firstWhere","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}},"orElse":{"name":"orElse","optional":true,"named":true,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.IterableBase.E","inner":[]}],"parameters":{}}}},"annotations":[]},"fold":{"name":"fold","qualifiedName":"dart:core.Set.fold","comment":"<p>Reduces a collection to a single value by iteratively combining each\nelement of the collection with an existing value</p>\n<p>Uses <a>dart:core.Set.fold.initialValue</a> as the initial value,\nthen iterates through the elements and updates the value with\neach element using the <a>dart:core.Set.fold.combine</a> function, as if by:</p>\n<pre><code>var value = initialValue;\nfor (E element in this) {\n  value = combine(value, element);\n}\nreturn value;\n</code></pre>\n<p>Example of calculating the sum of an iterable:</p>\n<pre><code>iterable.fold(0, (prev, element) =&gt; prev + element);\n</code></pre>","commentFrom":"dart:core.Iterable.fold","inheritedFrom":"dart:core.IterableBase.fold","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"initialValue":{"name":"initialValue","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"combine":{"name":"combine","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{"previousValue":{"name":"previousValue","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"forEach":{"name":"forEach","qualifiedName":"dart:core.Set.forEach","comment":"<p>Applies the function <a>dart:core.Set.forEach.f</a> to each element of this collection in iteration\norder.</p>","commentFrom":"dart:core.Iterable.forEach","inheritedFrom":"dart:core.IterableBase.forEach","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"join":{"name":"join","qualifiedName":"dart:core.Set.join","comment":"<p>Converts each element to a <a>dart:core.String</a> and concatenates the strings.</p>\n<p>Iterates through elements of this iterable,\nconverts each one to a <a>dart:core.String</a> by calling <a>dart:core.Set.toString</a>,\nand then concatenates the strings, with the\n<a>dart:core.Set.join.separator</a> string interleaved between the elements.</p>","commentFrom":"dart:core.Iterable.join","inheritedFrom":"dart:core.IterableBase.join","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.String","inner":[]}],"parameters":{"separator":{"name":"separator","optional":true,"named":false,"default":true,"type":[{"outer":"dart:core.String","inner":[]}],"value":"\"\"","annotations":[]}},"annotations":[]},"lastWhere":{"name":"lastWhere","qualifiedName":"dart:core.Set.lastWhere","comment":"<p>Returns the last element that satisfies the given predicate <a>dart:core.Set.lastWhere.test</a>.</p>\n<p>An iterable that can access its elements directly may check its\nelements in any order (for example a list starts by checking the\nlast element and then moves towards the start of the list).\nThe default implementation iterates elements in iteration order,\nchecks <code>test(element)</code> for each,\nand finally returns that last one that matched.</p>\n<p>If no element satsfies <a>dart:core.Set.lastWhere.test</a>, the result of invoking the <a>dart:core.Set.lastWhere.orElse</a>\nfunction is returned.\nIf <a>dart:core.Set.lastWhere.orElse</a> is omitted, it defaults to throwing a <a>dart:core.StateError</a>.</p>","commentFrom":"dart:core.Iterable.lastWhere","inheritedFrom":"dart:core.IterableBase.lastWhere","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}},"orElse":{"name":"orElse","optional":true,"named":true,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.IterableBase.E","inner":[]}],"parameters":{}}}},"annotations":[]},"map":{"name":"map","qualifiedName":"dart:core.Set.map","comment":"<p>Returns a new lazy <a>dart:core.Iterable</a> with elements that are created by\ncalling <code>f</code> on each element of this <code>Iterable</code> in iteration order.</p>\n<p>This method returns a view of the mapped elements. As long as the\nreturned <a>dart:core.Iterable</a> is not iterated over, the supplied function <a>dart:core.Set.map.f</a> will\nnot be invoked. The transformed elements will not be cached. Iterating\nmultiple times over the the returned <a>dart:core.Iterable</a> will invoke the supplied\nfunction <a>dart:core.Set.map.f</a> multiple times on the same element.</p>\n<p>Methods on the returned iterable are allowed to omit calling <code>f</code>\non any element where the result isn't needed.\nFor example, <a>dart:core.Set.elementAt</a> may call <code>f</code> only once.</p>","commentFrom":"dart:core.Iterable.map","inheritedFrom":"dart:core.IterableBase.map","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Iterable","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart:core.Set.noSuchMethod","comment":"<p><a>dart:core.Set.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart:core.Set.noSuchMethod</a> in an <a>dart:core.Invocation</a>.\nIf <a>dart:core.Set.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart:core.Set.noSuchMethod</a> is to throw a\n<a>dart:core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"reduce":{"name":"reduce","qualifiedName":"dart:core.Set.reduce","comment":"<p>Reduces a collection to a single value by iteratively combining elements\nof the collection using the provided function.</p>\n<p>The iterable must have at least one element.\nIf it has only one element, that element is returned.</p>\n<p>Otherwise this method starts with the first element from the iterator,\nand then combines it with the remaining elements in iteration order,\nas if by:</p>\n<pre><code>E value = iterable.first;\niterable.skip(1).forEach((element) {\n  value = combine(value, element);\n});\nreturn value;\n</code></pre>\n<p>Example of calculating the sum of an iterable:</p>\n<pre><code>iterable.reduce((value, element) =&gt; value + element);\n</code></pre>","commentFrom":"dart:core.Iterable.reduce","inheritedFrom":"dart:core.IterableBase.reduce","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{"combine":{"name":"combine","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.IterableBase.E","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]},"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"singleWhere":{"name":"singleWhere","qualifiedName":"dart:core.Set.singleWhere","comment":"<p>Returns the single element that satisfies <a>dart:core.Set.singleWhere.test</a>.</p>\n<p>Checks all elements to see if <code>test(element)</code> returns true.\nIf exactly one element satisfies <a>dart:core.Set.singleWhere.test</a>, that element is returned.\nOtherwise, if there are no matching elements, or if there is more than\none matching element, a <a>dart:core.StateError</a> is thrown.</p>","commentFrom":"dart:core.Iterable.singleWhere","inheritedFrom":"dart:core.IterableBase.singleWhere","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.int","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"skip":{"name":"skip","qualifiedName":"dart:core.Set.skip","comment":"<p>Returns an Iterable that provides all but the first count elements.</p>\n<p>When the returned iterable is iterated, it starts iterating over <code>this</code>,\nfirst skipping past the initial count elements.\nIf <code>this</code> has fewer than <code>count</code> elements, then the resulting Iterable is\nempty.\nAfter that, the remaining elements are iterated in the same order as\nin this iterable.</p>\n<p>The <code>count</code> must not be negative.</p>","commentFrom":"dart:core.Iterable.skip","inheritedFrom":"dart:core.IterableBase.skip","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.int","inner":[]}]}],"parameters":{"n":{"name":"n","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"skipWhile":{"name":"skipWhile","qualifiedName":"dart:core.Set.skipWhile","comment":"<p>Returns an Iterable that skips leading elements while <a>dart:core.Set.skipWhile.test</a> is satisfied.</p>\n<p>The filtering happens lazily. Every new Iterator of the returned\nIterable iterates over all elements of <code>this</code>.</p>\n<p>The returned iterable provides elements by iterating this iterable,\nbut skipping over all initial elements where <code>test(element)</code> returns\ntrue. If all elements satisfy <code>test</code> the resulting iterable is empty,\notherwise it iterates the remaining elements in their original order,\nstarting with the first element for which <code>test(element)</code> returns false,</p>","commentFrom":"dart:core.Iterable.skipWhile","inheritedFrom":"dart:core.IterableBase.skipWhile","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.int","inner":[]}]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"take":{"name":"take","qualifiedName":"dart:core.Set.take","comment":"<p>Returns a lazy iterable of the count first elements of this iterable.</p>\n<p>The returned <code>Iterable</code> may contain fewer than <code>count</code> elements, if <code>this</code>\ncontains fewer than <code>count</code> elements.</p>\n<p>The elements can be computed by stepping through <a>dart:core.Set.iterator</a> until count\nelements have been seen.</p>\n<p>The <code>count</code> must not be negative.</p>","commentFrom":"dart:core.Iterable.take","inheritedFrom":"dart:core.IterableBase.take","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.int","inner":[]}]}],"parameters":{"n":{"name":"n","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"takeWhile":{"name":"takeWhile","qualifiedName":"dart:core.Set.takeWhile","comment":"<p>Returns a lazy iterable of the leading elements satisfying <a>dart:core.Set.takeWhile.test</a>.</p>\n<p>The filtering happens lazily. Every new iterator of the returned\niterable starts iterating over the elements of <code>this</code>.</p>\n<p>The elements can be computed by stepping through <a>dart:core.Set.iterator</a> until an\nelement is found where <code>test(element)</code> is false. At that point,\nthe returned iterable stops (its <code>moveNext()</code> returns false).</p>","commentFrom":"dart:core.Iterable.takeWhile","inheritedFrom":"dart:core.IterableBase.takeWhile","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.int","inner":[]}]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"toList":{"name":"toList","qualifiedName":"dart:core.Set.toList","comment":"<p>Creates a <a>dart:core.List</a> containing the elements of this <a>dart:core.Iterable</a>.</p>\n<p>The elements are in iteration order.\nThe list is fixed-length if <a>dart:core.Set.toList.growable</a> is false.</p>","commentFrom":"dart:core.Iterable.toList","inheritedFrom":"dart:core.IterableBase.toList","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.List","inner":[{"outer":"dart:core.int","inner":[]}]}],"parameters":{"growable":{"name":"growable","optional":true,"named":true,"default":true,"type":[{"outer":"dart:core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]},"toSet":{"name":"toSet","qualifiedName":"dart:core.Set.toSet","comment":"<p>Creates a <a>dart:core.Set</a> containing the same elements as this iterable.</p>\n<p>The set may contain fewer elements than the iterable,\nif the iterable contains an element more than once,\nor it contains one or more elements that are equal.\nThe order of the elements in the set is not guaranteed to be the same\nas for the iterable.</p>","commentFrom":"dart:core.Iterable.toSet","inheritedFrom":"dart:core.IterableBase.toSet","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Set","inner":[{"outer":"dart:core.int","inner":[]}]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart:core.Set.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart:core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.String","inner":[]}],"parameters":{},"annotations":[]},"where":{"name":"where","qualifiedName":"dart:core.Set.where","comment":"<p>Returns a new lazy <a>dart:core.Iterable</a> with all elements that satisfy the\npredicate test.</p>\n<p>The matching elements have the same order in the returned iterable\nas they have in <a>dart:core.Set.iterator</a>.</p>\n<p>This method returns a view of the mapped elements. As long as the\nreturned <a>dart:core.Iterable</a> is not iterated over, the supplied function test will\nnot be invoked. Iterating will not cache results, and thus iterating\nmultiple times over the returned <a>dart:core.Iterable</a> will invoke the supplied\nfunction test multiple times on the same element.</p>","commentFrom":"dart:core.Iterable.where","inheritedFrom":"dart:core.IterableBase.where","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart:core.Iterable","inner":[{"outer":"dart:core.int","inner":[]}]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart:core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart:core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]}}},"annotations":[],"generics":{"E":{"name":"E","type":"dart.core.Object"}}}